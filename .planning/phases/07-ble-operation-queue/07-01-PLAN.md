---
phase: 07-ble-operation-queue
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/BleOperationQueue.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/data/ble/BleOperationQueueTest.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/KableBleRepository.kt
autonomous: true

must_haves:
  truths:
    - "All BLE reads and writes pass through single BleOperationQueue"
    - "Concurrent BLE operations cannot interleave (Issue #222 prevention)"
    - "Write retry logic (3 attempts) preserved in extracted class"
    - "No direct bleOperationMutex access remains in KableBleRepository"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/BleOperationQueue.kt"
      provides: "Mutex-based BLE operation serialization"
      contains: "class BleOperationQueue"
    - path: "shared/src/commonTest/kotlin/com/devil/phoenixproject/data/ble/BleOperationQueueTest.kt"
      provides: "Unit tests for queue serialization and retry logic"
      contains: "class BleOperationQueueTest"
  key_links:
    - from: "KableBleRepository.kt"
      to: "BleOperationQueue.kt"
      via: "bleQueue property and method calls"
      pattern: "bleQueue\\.(read|write|withLock)"
---

<objective>
Extract BLE operation serialization from KableBleRepository into a dedicated BleOperationQueue class with Mutex-based serialization and write retry logic.

Purpose: Create a single enforcement point for BLE operation serialization to prevent Issue #222 (fault 16384 from interleaved operations). Makes the serialization pattern testable and ensures no BLE operation can bypass the queue.

Output: BleOperationQueue.kt with read/write/withLock methods, comprehensive unit tests, and KableBleRepository updated to use the extracted queue.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ble-operation-queue/07-RESEARCH.md

# Source file for extraction
@shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/KableBleRepository.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BleOperationQueue.kt with Mutex serialization</name>
  <files>shared/src/commonMain/kotlin/com/devil/phoenixproject/data/ble/BleOperationQueue.kt</files>
  <action>
    Create BleOperationQueue.kt in data/ble/ (same directory as BleConstants.kt and ProtocolParser.kt):

    ```kotlin
    package com.devil.phoenixproject.data.ble

    import com.juul.kable.Characteristic
    import com.juul.kable.Peripheral
    import com.juul.kable.WriteType
    import kotlinx.coroutines.delay
    import kotlinx.coroutines.sync.Mutex
    import kotlinx.coroutines.sync.withLock

    /**
     * Serializes all BLE operations through a single Mutex.
     * Prevents interleaving that causes fault 16384 (Issue #222).
     *
     * The parent repo (VitruvianRedux) uses Nordic BLE library's .enqueue()
     * which provides automatic serialization. Kable has no such feature,
     * so we must serialize manually via Mutex.
     *
     * IMPORTANT: Kotlin's Mutex is NOT reentrant. Never nest read()/write()/withLock() calls.
     */
    class BleOperationQueue {
        private val mutex = Mutex()

        /** Check if mutex is currently locked (for diagnostic logging). */
        val isLocked: Boolean get() = mutex.isLocked

        /**
         * Execute a read operation through the serialization gate.
         * All BLE reads MUST go through this method.
         */
        suspend fun <T> read(operation: suspend () -> T): T =
            mutex.withLock { operation() }

        /**
         * Execute a write operation with retry logic.
         * Retries on "Busy" errors with exponential backoff (50ms, 100ms, 150ms).
         *
         * @param peripheral The Kable peripheral to write to
         * @param characteristic The characteristic to write to
         * @param data The data to write
         * @param writeType Write type (WithResponse for V-Form, WithoutResponse for Trainer+)
         * @param maxRetries Maximum retry attempts (default: 3)
         * @return Result.success(Unit) on success, Result.failure(exception) on failure
         */
        suspend fun write(
            peripheral: Peripheral,
            characteristic: Characteristic,
            data: ByteArray,
            writeType: WriteType = WriteType.WithResponse,
            maxRetries: Int = 3
        ): Result<Unit> {
            var lastException: Exception? = null

            for (attempt in 0 until maxRetries) {
                try {
                    mutex.withLock {
                        peripheral.write(characteristic, data, writeType)
                    }
                    return Result.success(Unit)
                } catch (e: Exception) {
                    lastException = e
                    val isBusyError = e.message?.contains("Busy", ignoreCase = true) == true ||
                        e.message?.contains("WriteRequestBusy", ignoreCase = true) == true

                    if (isBusyError && attempt < maxRetries - 1) {
                        // Exponential backoff: 50ms, 100ms, 150ms
                        val delayMs = 50L * (attempt + 1)
                        delay(delayMs)
                    } else {
                        break
                    }
                }
            }
            return Result.failure(lastException ?: IllegalStateException("Unknown write error"))
        }

        /**
         * Execute a simple write without retry (for internal operations like heartbeat).
         * Use write() for user-facing operations that should retry on busy.
         */
        suspend fun writeSimple(
            peripheral: Peripheral,
            characteristic: Characteristic,
            data: ByteArray,
            writeType: WriteType = WriteType.WithResponse
        ) {
            mutex.withLock {
                peripheral.write(characteristic, data, writeType)
            }
        }

        /**
         * Execute a custom operation with the lock held.
         * Use for compound operations (read-then-write patterns).
         */
        suspend fun <T> withLock(operation: suspend () -> T): T =
            mutex.withLock { operation() }
    }
    ```

    This matches the pattern documented in 07-RESEARCH.md. The class provides:
    - read(): Serialized BLE reads
    - write(): Serialized BLE writes with 3-attempt retry and exponential backoff
    - writeSimple(): Serialized writes without retry (for heartbeat/internal ops)
    - withLock(): For compound operations
    - isLocked: Diagnostic property for logging
  </action>
  <verify>File compiles: `./gradlew :shared:compileKotlinAndroid 2>&1 | tail -5`</verify>
  <done>BleOperationQueue.kt exists with read(), write(), writeSimple(), and withLock() methods</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for BleOperationQueue</name>
  <files>shared/src/commonTest/kotlin/com/devil/phoenixproject/data/ble/BleOperationQueueTest.kt</files>
  <action>
    Create BleOperationQueueTest.kt with comprehensive tests for serialization and retry logic:

    ```kotlin
    package com.devil.phoenixproject.data.ble

    import kotlinx.coroutines.async
    import kotlinx.coroutines.delay
    import kotlinx.coroutines.test.runTest
    import kotlin.test.Test
    import kotlin.test.assertEquals
    import kotlin.test.assertFalse
    import kotlin.test.assertTrue

    class BleOperationQueueTest {

        @Test
        fun `isLocked returns false when idle`() {
            val queue = BleOperationQueue()
            assertFalse(queue.isLocked)
        }

        @Test
        fun `isLocked returns true when operation in progress`() = runTest {
            val queue = BleOperationQueue()
            val job = async {
                queue.read {
                    assertTrue(queue.isLocked)
                    delay(10)
                }
            }
            delay(1) // Give the async a moment to start
            assertTrue(queue.isLocked)
            job.await()
            assertFalse(queue.isLocked)
        }

        @Test
        fun `read serializes concurrent calls`() = runTest {
            val queue = BleOperationQueue()
            val results = mutableListOf<Int>()

            // Launch multiple concurrent reads
            val jobs = (1..5).map { i ->
                async {
                    queue.read {
                        // Record entry order
                        results.add(i)
                        delay(5)
                        // Verify no interleaving - size should equal i at this point
                        results.size
                    }
                }
            }

            val sizes = jobs.map { it.await() }

            // Each operation should see monotonically increasing size
            // (proves no interleaving - each completed before next started)
            assertEquals(listOf(1, 2, 3, 4, 5), sizes)
        }

        @Test
        fun `withLock serializes operations`() = runTest {
            val queue = BleOperationQueue()
            var counter = 0

            val jobs = (1..3).map {
                async {
                    queue.withLock {
                        val before = counter
                        delay(5)
                        counter = before + 1
                        counter
                    }
                }
            }

            val results = jobs.map { it.await() }

            // Each withLock should see the result of the previous one
            assertEquals(listOf(1, 2, 3), results)
        }

        @Test
        fun `read returns operation result`() = runTest {
            val queue = BleOperationQueue()
            val result = queue.read { "test-value" }
            assertEquals("test-value", result)
        }

        @Test
        fun `withLock returns operation result`() = runTest {
            val queue = BleOperationQueue()
            val result = queue.withLock { 42 }
            assertEquals(42, result)
        }
    }
    ```

    NOTE: Testing write() and writeSimple() requires mocking Peripheral, which is complex in commonTest.
    The critical serialization behavior is tested via read() and withLock() which use the same mutex.
    Integration testing with actual BLE hardware is covered by QUEUE-02 (separate integration test).
  </action>
  <verify>Tests pass: `./gradlew :shared:testDebugUnitTest --tests "com.devil.phoenixproject.data.ble.BleOperationQueueTest" 2>&1 | tail -20`</verify>
  <done>All BleOperationQueue unit tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Update KableBleRepository to use BleOperationQueue</name>
  <files>shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/KableBleRepository.kt</files>
  <action>
    Update KableBleRepository.kt to use the extracted BleOperationQueue. This is a careful refactoring to ensure all 10 BLE operation sites use the queue.

    **Step 1: Add import and property**
    Add at top of file with other imports:
    ```kotlin
    import com.devil.phoenixproject.data.ble.BleOperationQueue
    ```

    Add property near line 229 (replacing bleOperationMutex):
    ```kotlin
    // Issue #222: All BLE operations serialized through single queue
    private val bleQueue = BleOperationQueue()
    ```

    **Step 2: Remove old serialization code (lines ~229-258)**
    Delete these declarations:
    - `private val bleOperationMutex = Mutex()`
    - `private suspend fun <T> serializedRead(...)`
    - `private suspend fun serializedWrite(...)`

    **Step 3: Update performHeartbeatRead() (~line 871)**
    Change from:
    ```kotlin
    bleOperationMutex.withLock { p.read(txCharacteristic) }
    ```
    To:
    ```kotlin
    bleQueue.read { p.read(txCharacteristic) }
    ```

    **Step 4: Update sendHeartbeatNoOp() (~line 890)**
    Change from:
    ```kotlin
    bleOperationMutex.withLock { p.write(...) }
    ```
    To:
    ```kotlin
    bleQueue.writeSimple(p, txCharacteristic, BleConstants.HEARTBEAT_NO_OP, WriteType.WithResponse)
    ```

    **Step 5: Update firmware version read (~line 1015)**
    Change from:
    ```kotlin
    bleOperationMutex.withLock { p.read(firmwareRevisionCharacteristic) }
    ```
    To:
    ```kotlin
    bleQueue.read { p.read(firmwareRevisionCharacteristic) }
    ```

    **Step 6: Update version characteristic read (~line 1043)**
    Change from:
    ```kotlin
    bleOperationMutex.withLock { p.read(versionCharacteristic) }
    ```
    To:
    ```kotlin
    bleQueue.read { p.read(versionCharacteristic) }
    ```

    **Step 7: Update diagnostic characteristic read (~line 1072)**
    Change from:
    ```kotlin
    bleOperationMutex.withLock { p.read(diagnosticCharacteristic) }
    ```
    To:
    ```kotlin
    bleQueue.read { p.read(diagnosticCharacteristic) }
    ```

    **Step 8: Update heuristic characteristic read (~line 1123)**
    Change from:
    ```kotlin
    bleOperationMutex.withLock { p.read(heuristicCharacteristic) }
    ```
    To:
    ```kotlin
    bleQueue.read { p.read(heuristicCharacteristic) }
    ```

    **Step 9: Update monitor characteristic read (~line 1274)**
    Change from:
    ```kotlin
    bleOperationMutex.withLock { p.read(monitorCharacteristic) }
    ```
    To:
    ```kotlin
    bleQueue.read { p.read(monitorCharacteristic) }
    ```

    **Step 10: Update sendWorkoutCommand() (~lines 1405-1449)**
    This is the most complex change. Replace the entire retry loop with:
    ```kotlin
    // Issue #222: Log mutex state before acquiring for debugging
    log.d { "BLE queue locked: ${bleQueue.isLocked}, acquiring..." }

    val attemptStart = currentTimeMillis()
    val result = bleQueue.write(p, txCharacteristic, command, WriteType.WithResponse)

    if (result.isSuccess) {
        val elapsedMs = currentTimeMillis() - attemptStart
        log.d { "TX write ok: size=${command.size}, type=WithResponse, elapsed=${elapsedMs}ms" }
        log.i { "Command sent via NUS TX: ${command.size} bytes" }

        // Issue #222 v16 (optional): One-shot diagnostic read after CONFIG...
        // [keep existing post-CONFIG diagnostic read logic unchanged]

        logRepo.debug(...)
        return Result.success(Unit)
    } else {
        val ex = result.exceptionOrNull()
        log.e { "Failed to send command after retries: ${ex?.message}" }
        return Result.failure(ex ?: IllegalStateException("Unknown error"))
    }
    ```

    **Step 11: Update post-CONFIG diagnostic read (~line 1427)**
    Change from:
    ```kotlin
    bleOperationMutex.withLock { p.read(diagnosticCharacteristic) }
    ```
    To:
    ```kotlin
    bleQueue.read { p.read(diagnosticCharacteristic) }
    ```

    **Verification checklist:**
    - No remaining `bleOperationMutex` references
    - No remaining `serializedRead` or `serializedWrite` calls
    - All `p.read(` and `p.write(` are inside bleQueue.read{} or bleQueue.write() calls
  </action>
  <verify>
    Build compiles: `./gradlew :shared:compileKotlinAndroid 2>&1 | tail -5`
    No remaining mutex: `grep -c "bleOperationMutex" shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/KableBleRepository.kt` should return 0
  </verify>
  <done>KableBleRepository uses bleQueue for all BLE operations, bleOperationMutex and serializedRead/serializedWrite removed</done>
</task>

</tasks>

<verification>
```bash
# Full verification
./gradlew :shared:testDebugUnitTest --tests "com.devil.phoenixproject.data.ble.BleOperationQueueTest"
./gradlew :androidApp:assembleDebug

# Verify no old mutex references remain
grep -c "bleOperationMutex" shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/KableBleRepository.kt
# Should return 0

# Verify bleQueue is used
grep -c "bleQueue" shared/src/commonMain/kotlin/com/devil/phoenixproject/data/repository/KableBleRepository.kt
# Should return 10+ (one declaration + all operation sites)
```
</verification>

<success_criteria>
1. BleOperationQueue.kt created with read(), write(), writeSimple(), withLock() methods
2. BleOperationQueue uses Mutex for serialization (Issue #222 prevention)
3. Write retry logic (3 attempts, 50/100/150ms backoff) preserved in write() method
4. All unit tests pass
5. KableBleRepository uses bleQueue for all 10 BLE operation sites
6. bleOperationMutex, serializedRead(), serializedWrite() removed from KableBleRepository
7. Android build compiles successfully
8. No functional change to BLE behavior
</success_criteria>

<output>
After completion, create `.planning/phases/07-ble-operation-queue/07-01-SUMMARY.md`
</output>
