---
phase: 02-manager-decomposition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutCoordinator.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/testutil/DWSMTestHarness.kt
autonomous: true
must_haves:
  truths:
    - "WorkoutCoordinator exists as a class holding all MutableStateFlows, guard flags, Job references, and mutable vars with zero business logic methods"
    - "DWSM reads/writes state through coordinator fields instead of local fields"
    - "DWSMTestHarness constructs WorkoutCoordinator and passes it to DWSM"
    - "All 38 characterization tests pass after extraction"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutCoordinator.kt"
      provides: "Shared state bus for all workout state"
      contains: "class WorkoutCoordinator"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt"
      provides: "DWSM with state delegated to coordinator"
      contains: "coordinator."
  key_links:
    - from: "DefaultWorkoutSessionManager.kt"
      to: "WorkoutCoordinator.kt"
      via: "val coordinator property"
      pattern: "val coordinator"
    - from: "DWSMTestHarness.kt"
      to: "WorkoutCoordinator.kt"
      via: "construction in harness"
      pattern: "WorkoutCoordinator"
---

<objective>
Extract all MutableStateFlows, guard flags, Job references, and mutable vars from DefaultWorkoutSessionManager into a new WorkoutCoordinator class (shared state bus with zero business logic methods).

Purpose: WorkoutCoordinator is the foundation that RoutineFlowManager and ActiveSessionEngine will both read/write through. Extracting state first is zero-risk (no logic changes) and unblocks all subsequent plans.

Output: WorkoutCoordinator.kt (~300 lines), DWSM updated to use coordinator.field instead of local fields, test harness updated, all 38 tests passing.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-manager-decomposition/02-RESEARCH.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
@shared/src/commonTest/kotlin/com/devil/phoenixproject/testutil/DWSMTestHarness.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkoutCoordinator and migrate all state fields from DWSM</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutCoordinator.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/testutil/DWSMTestHarness.kt
  </files>
  <action>
**CRITICAL: Test after every atomic move. Commit after each passing test run.**

**Step 1: Create WorkoutCoordinator.kt** in the same package as DWSM (`com.devil.phoenixproject.presentation.manager`).

The coordinator class receives `_hapticEvents: MutableSharedFlow<HapticEvent>` in its constructor (since DWSM currently receives it and it's shared state).

Extract ALL of the following from DWSM (lines ~181-375) into WorkoutCoordinator:
- All `MutableStateFlow` fields (approximately 25+): `_workoutState`, `_routineFlowState`, `_currentMetric`, `_currentHeuristicKgMax`, `_loadBaselineA`, `_loadBaselineB`, `_workoutParameters`, `_repCount`, `_timedExerciseRemainingSeconds`, `_repRanges`, `_autoStopState`, `_autoStartCountdown`, `_routines`, `_loadedRoutine`, `_currentExerciseIndex`, `_currentSetIndex`, `_skippedExercises`, `_completedExercises`, `_currentSetRpe`, `_cycleDayCompletionEvent`, `_hapticEvents`, `_userFeedbackEvents`, `_isCurrentTimedCableExercise`, `_isCurrentExerciseBodyweight`
- All public `StateFlow` / `SharedFlow` getters (the `val xxx: StateFlow<T> get() = _xxx.asStateFlow()` properties)
- All private mutable vars: `maxHeuristicKgMax`, `_userAdjustedWeightDuringRest`, `currentSessionId`, `workoutStartTime`, `routineStartTime`, `collectedMetrics`, `currentRoutineSessionId`, `currentRoutineName`, `activeCycleId`, `activeCycleDayNumber`, `autoStopStartTime`, `autoStopTriggered`, `autoStopStopRequested`, `stopWorkoutInProgress`, `setCompletionInProgress`, `currentHandleState`, `stallStartTime`, `isCurrentlyStalled`, `bodyweightSetsCompletedInRoutine`, `previousExerciseWasBodyweight`, `skipCountdownRequested`, `isCurrentWorkoutTimed`, `handleDetectionEnabledTimestamp`
- All Job references: `monitorDataCollectionJob`, `autoStartJob`, `restTimerJob`, `bodyweightTimerJob`, `repEventsCollectionJob`, `workoutJob`
- The `companion object` constants (AUTO_STOP_DURATION_SECONDS, STALL_*, HANDLE_REST_THRESHOLD, MIN_RANGE_THRESHOLD, AMRAP_STARTUP_GRACE_MS) — move to WorkoutCoordinator's companion. Keep `TEMP_SINGLE_EXERCISE_PREFIX` in DWSM (it's a routine-domain constant used by CRUD methods).

Use `internal` visibility on mutable fields so sub-managers in the same module can access them. Keep public `StateFlow` getters for the ViewModel layer.

**Step 2: Update DWSM to use coordinator.**

Add `val coordinator = WorkoutCoordinator(_hapticEvents)` as the first property in DWSM. Remove `_hapticEvents` from DWSM's constructor — it will be created inside the coordinator or passed through.

Actually, on reflection: keep `_hapticEvents` in DWSM constructor (MainViewModel passes it), then pass it to WorkoutCoordinator's constructor. This preserves the existing construction API.

Replace ALL references to extracted fields in DWSM with `coordinator.fieldName`. For example:
- `_workoutState.value` → `coordinator._workoutState.value`
- `workoutJob?.cancel()` → `coordinator.workoutJob?.cancel()`
- `stopWorkoutInProgress` → `coordinator.stopWorkoutInProgress`

The `WorkoutStateProvider` implementation in DWSM should delegate to coordinator:
```kotlin
override val workoutState: StateFlow<WorkoutState> get() = coordinator.workoutState
override val workoutParameters: StateFlow<WorkoutParameters> get() = coordinator.workoutParameters
```

**Do this incrementally:** Move 3-5 fields at a time, update all DWSM references, compile check, run tests. Commit each passing batch.

**Step 3: Update DWSMTestHarness.**

The harness currently constructs DWSM directly. After this change, DWSM internally creates the coordinator, so the harness needs NO constructor changes. However, add a convenience accessor:
```kotlin
val coordinator get() = dwsm.coordinator
```

This allows future tests to inspect coordinator state directly if needed.

**Step 4: Run full test suite and commit.**

```bash
./gradlew :shared:testDebugUnitTest
```

All 38 tests MUST pass. If any fail, revert the last batch and retry with smaller batches.

**IMPORTANT CONSTRAINTS (from user decisions):**
- WorkoutCoordinator has ZERO business logic methods — only state fields, getters, and companion constants
- ALL state goes in coordinator (not just cross-cutting state)
- Sub-managers will access state via `internal` fields — not through getters
- Managers stay OUT of Koin — manual construction
  </action>
  <verify>
Run `./gradlew :shared:testDebugUnitTest` — all 38 tests pass.
Verify WorkoutCoordinator.kt exists and contains zero methods (only properties, companion constants).
Verify DWSM no longer has MutableStateFlow declarations (all delegated to coordinator).
  </verify>
  <done>
WorkoutCoordinator.kt exists with all state fields. DWSM references coordinator for all state. All 38 characterization tests pass. Git history shows atomic commits per batch of fields moved.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew :shared:testDebugUnitTest` — all 38 tests pass
2. `grep -c "MutableStateFlow" WorkoutCoordinator.kt` returns 20+ (all state flows moved)
3. `grep -c "private val _.*= MutableStateFlow" DefaultWorkoutSessionManager.kt` returns 0 (none remain)
4. WorkoutCoordinator has no `fun` declarations (zero methods, only properties)
5. DWSM still implements WorkoutStateProvider
</verification>

<success_criteria>
- WorkoutCoordinator.kt exists as a pure state bus (~300 lines, zero methods)
- DWSM accesses all state through coordinator property
- DWSMTestHarness builds without changes to its constructor call
- All 38 Phase 1 characterization tests pass
- Atomic git commits per batch of fields moved
</success_criteria>

<output>
After completion, create `.planning/phases/02-manager-decomposition/02-01-SUMMARY.md`
</output>
