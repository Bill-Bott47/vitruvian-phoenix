---
phase: 02-manager-decomposition
plan: 03
type: execute
wave: 3
depends_on: ["02-01"]
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/RoutineFlowManager.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/testutil/DWSMTestHarness.kt
autonomous: true
must_haves:
  truths:
    - "RoutineFlowManager exists as a concrete class handling all routine CRUD, exercise/set navigation, and superset navigation"
    - "RoutineFlowManager communicates only through WorkoutCoordinator — never holds references to ActiveSessionEngine or DWSM"
    - "DWSM delegates routine methods to routineFlowManager"
    - "Init block collectors 1-2 (routines loader, exercise importer) run inside RoutineFlowManager"
    - "All 38 characterization tests pass after extraction"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/RoutineFlowManager.kt"
      provides: "Routine CRUD, navigation, superset management"
      contains: "class RoutineFlowManager"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt"
      provides: "DWSM with routine methods delegated to routineFlowManager"
      contains: "routineFlowManager."
  key_links:
    - from: "RoutineFlowManager.kt"
      to: "WorkoutCoordinator.kt"
      via: "coordinator property for state access"
      pattern: "coordinator\\."
    - from: "DefaultWorkoutSessionManager.kt"
      to: "RoutineFlowManager.kt"
      via: "delegation of routine methods"
      pattern: "routineFlowManager\\."
---

<objective>
Extract all routine CRUD, exercise/set navigation, superset navigation, and related init block collectors from DefaultWorkoutSessionManager into a new RoutineFlowManager class (~1,200 lines).

Purpose: RoutineFlowManager is the lower-coupling extraction (compared to ActiveSessionEngine). Extracting it first reduces DWSM by ~30% and validates the coordinator-based communication pattern before the larger ActiveSessionEngine extraction.

Output: RoutineFlowManager.kt (~1,200 lines), DWSM reduced by ~1,200 lines with routine methods delegated, all 38 tests passing.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-manager-decomposition/02-RESEARCH.md
@.planning/phases/02-manager-decomposition/02-01-SUMMARY.md
@.planning/phases/02-manager-decomposition/02-02-SUMMARY.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutCoordinator.kt
@shared/src/commonTest/kotlin/com/devil/phoenixproject/testutil/DWSMTestHarness.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoutineFlowManager and extract routine methods from DWSM</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/RoutineFlowManager.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
  </files>
  <action>
**CRITICAL: Move methods one at a time (or in small tightly-coupled groups). Run all 38 tests after EACH move. Commit after each passing test run. Revert immediately on any failure.**

**Step 1: Create RoutineFlowManager.kt scaffold.**

Create the class in the same package as DWSM:
```kotlin
class RoutineFlowManager(
    val coordinator: WorkoutCoordinator,
    private val workoutRepository: WorkoutRepository,
    private val exerciseRepository: ExerciseRepository,
    private val resolveWeightsUseCase: ResolveRoutineWeightsUseCase,
    private val completedSetRepository: CompletedSetRepository,
    private val scope: CoroutineScope
)
```

Note: RoutineFlowManager receives the SAME CoroutineScope as DWSM (critical for TestScope compatibility). NO sub-manager creates its own scope.

**Step 2: Move init block collectors 1-2 into RoutineFlowManager.**

The RoutineFlowManager's `init {}` block should launch:
1. **Routines loader** (DWSM lines ~383-388): `workoutRepository.getAllRoutines().collect` writing to `coordinator._routines`
2. **Exercise importer** (DWSM lines ~391-402): `exerciseRepository.importExercises()`

Remove these 2 collectors from DWSM's init block. Run tests after moving each one.

IMPORTANT: Document the original ordering. In DWSM, the routines loader was collector #1 and exercise importer was #2. In RoutineFlowManager, they should launch in the same order. Since RoutineFlowManager is constructed before ActiveSessionEngine in DWSM, its init block runs first — preserving the original ordering.

**Step 3: Extract Superset Navigation Helpers (Round 1 area, private methods).**

Move these private methods to RoutineFlowManager (they only read coordinator state):
- `getCurrentSupersetExercises()`
- `isInSuperset()`
- `getNextSupersetExerciseIndex()`
- `getFirstSupersetExerciseIndex()`
- `isAtEndOfSupersetCycle()`
- `getSupersetRestSeconds()`
- `findNextExerciseAfterCurrent()`

Update all state references from direct fields to `coordinator.field`. Run tests. Commit.

**Step 4: Extract Unified Navigation Logic (private methods).**

Move:
- `getNextStep(routine, exIndex, setIndex)`
- `getPreviousStep(routine, exIndex, setIndex)`
- `hasNextStep()` / `hasPreviousStep()`
- `calculateNextExerciseName(...)`
- `calculateIsLastExercise(...)`

These call the superset helpers moved in Step 3. Run tests. Commit.

**Step 5: Extract Routine CRUD (Round 3, simple delegation methods).**

Move:
- `saveRoutine(routine)` — delegates to workoutRepository
- `updateRoutine(routine)` — delegates to workoutRepository
- `deleteRoutine(routineId)` — delegates to workoutRepository
- `deleteRoutines(routineIds)` — batch delete
- `getRoutineById(routineId)` — lookup from coordinator._routines

Run tests. Commit.

**Step 6: Extract Routine Loading methods.**

Move:
- `resolveRoutineWeights(routine)` — uses resolveWeightsUseCase
- `loadRoutineInternal(routine)` — sets coordinator state from first exercise
- `loadRoutine(routine)` — launches coroutine for resolve then load
- `loadRoutineById(routineId)` — lookup + load
- `enterRoutineOverview(routine)` — sets Overview state

Run tests. Commit.

**Step 7: Extract SetReady Navigation methods.**

Move:
- `enterSetReady(exerciseIndex, setIndex)`
- `enterSetReadyWithAdjustments(...)`
- `updateSetReadyWeight(weight)`
- `updateSetReadyReps(reps)`
- `updateSetReadyEchoLevel(level)`
- `updateSetReadyEccentricLoad(percent)`
- `returnToOverview()`
- `exitRoutineFlow()`
- `showRoutineComplete()`
- `clearLoadedRoutine()`

Run tests. Commit.

**Step 8: Extract Exercise Navigation methods.**

Move:
- `selectExerciseInOverview(index)`
- `navigateToExerciseInternal(routine, index)`
- `advanceToNextExercise()`
- `skipCurrentExercise()`
- `goToPreviousExercise()`
- `canGoBack()` / `canSkipForward()`
- `getRoutineExerciseNames()`
- `setReadyPrev()` / `setReadySkip()`

**IMPORTANT for jumpToExercise():** This method contains BLE commands (sendStopCommand, stopWorkout) and calls startWorkout. It needs a callback/delegate to DWSM for those operations. Options:
- Pass a `suspend () -> Unit` lambda for the BLE stop + startWorkout sequence
- Have RoutineFlowManager hold a reference to a `WorkoutLifecycleDelegate` interface implemented by DWSM
- Keep jumpToExercise() in DWSM as orchestration

Recommended: Keep `jumpToExercise()` in RoutineFlowManager but accept a lambda or interface for BLE/startWorkout calls. The navigation decision logic belongs here; the BLE execution delegates back to DWSM. Use Claude's discretion on the exact mechanism.

Also move `startSetFromReady()` — this calls startWorkout which is a DWSM/ActiveSessionEngine method. Same delegation pattern.

Run tests. Commit.

**Step 9: Extract Superset CRUD (Round 4).**

Move:
- `createSuperset(...)`, `updateSuperset(...)`, `deleteSuperset(...)`
- `addExerciseToSuperset(...)`, `removeExerciseFromSuperset(...)`

Run tests. Commit.

**Step 10: Extract State Query helpers.**

Move:
- `getCurrentExercise()` — reads coordinator state
- `hasResumableProgress(routineId)` — checks state
- `getResumableProgressInfo()` — display data
- `logRpeForCurrentSet(rpe)` — RPE tracking

Run tests. Commit.

**Step 11: Update DWSM to delegate all moved methods.**

In DWSM, replace method bodies with delegation:
```kotlin
fun loadRoutine(routine: Routine) = routineFlowManager.loadRoutine(routine)
fun saveRoutine(routine: Routine) = routineFlowManager.saveRoutine(routine)
// etc.
```

DWSM constructs RoutineFlowManager:
```kotlin
val routineFlowManager = RoutineFlowManager(
    coordinator = coordinator,
    workoutRepository = workoutRepository,
    exerciseRepository = exerciseRepository,
    resolveWeightsUseCase = resolveWeightsUseCase,
    completedSetRepository = completedSetRepository,
    scope = scope
)
```

Run tests. Commit.

**SHARED HELPERS:** `isBodyweightExercise()` and `isSingleExerciseMode()` are used by both RoutineFlowManager and ActiveSessionEngine. Make them top-level package functions or place on WorkoutCoordinator as extension functions. Claude's discretion on exact placement — just ensure both managers can call them.

**CONSTRAINTS (from user decisions):**
- RoutineFlowManager NEVER holds a reference to ActiveSessionEngine
- All state access through coordinator
- Same CoroutineScope as DWSM (NO new scope creation)
- Test after EVERY method move
- Atomic git commits per move
  </action>
  <verify>
Run `./gradlew :shared:testDebugUnitTest` — all 38 tests pass.
Verify RoutineFlowManager.kt exists and is ~1,200 lines.
Verify DWSM's routine methods are delegation-only (no logic bodies).
  </verify>
  <done>
RoutineFlowManager.kt exists with all routine CRUD, navigation, and superset logic. DWSM's routine methods are thin delegations. Init block collectors 1-2 moved to RoutineFlowManager. All 38 tests pass. Atomic git commits for every move.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update DWSMTestHarness for RoutineFlowManager construction</name>
  <files>
    shared/src/commonTest/kotlin/com/devil/phoenixproject/testutil/DWSMTestHarness.kt
  </files>
  <action>
DWSM now internally constructs RoutineFlowManager, so the test harness constructor call should NOT change. However, verify:

1. The harness still compiles and works after the extraction
2. Add convenience accessor if useful: `val routineFlowManager get() = dwsm.routineFlowManager`
3. Run all 38 tests one final time to confirm end-to-end

If the harness needed no changes (because DWSM handles sub-manager construction internally), just document this in the summary — the test is still mandatory.
  </action>
  <verify>
Run `./gradlew :shared:testDebugUnitTest` — all 38 tests pass.
  </verify>
  <done>
DWSMTestHarness works with RoutineFlowManager extraction. All 38 tests pass.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew :shared:testDebugUnitTest` — all 38 tests pass
2. RoutineFlowManager.kt exists in the manager package
3. DWSM routine methods are delegation stubs (grep for `routineFlowManager.` in DWSM)
4. RoutineFlowManager does NOT import or reference ActiveSessionEngine
5. RoutineFlowManager reads/writes state exclusively through coordinator
</verification>

<success_criteria>
- RoutineFlowManager.kt exists (~1,200 lines) with routine CRUD, navigation, superset logic
- DWSM routine methods reduced to delegation stubs
- Init block collectors 1-2 moved to RoutineFlowManager
- RoutineFlowManager communicates only through WorkoutCoordinator (no cross-manager references)
- All 38 Phase 1 characterization tests pass
- Atomic git commits per method move
</success_criteria>

<output>
After completion, create `.planning/phases/02-manager-decomposition/02-03-SUMMARY.md`
</output>
