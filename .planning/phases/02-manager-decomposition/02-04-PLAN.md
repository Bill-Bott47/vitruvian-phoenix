---
phase: 02-manager-decomposition
plan: 04
type: execute
wave: 4
depends_on: ["02-02", "02-03"]
files_modified:
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutSessionManager.kt
  - shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/viewmodel/MainViewModel.kt
  - shared/src/commonTest/kotlin/com/devil/phoenixproject/testutil/DWSMTestHarness.kt
autonomous: true
must_haves:
  truths:
    - "ActiveSessionEngine exists as a concrete class handling workout start/stop, rep processing, auto-stop, weight adjustment, Just Lift, training cycles, rest timer, and session persistence"
    - "ActiveSessionEngine communicates only through WorkoutCoordinator — never holds references to RoutineFlowManager"
    - "DWSM is reduced to an orchestration layer (~800 lines) that delegates to sub-managers and coordinates cross-cutting flows"
    - "Init block collectors 3-8 run inside ActiveSessionEngine"
    - "handleMonitorMetric() lives in ActiveSessionEngine (hot path, zero routine dependencies)"
    - "proceedFromSummary() stays in DWSM as orchestration (reads both routine + workout state)"
    - "MainViewModel public API is unchanged — no UI screen modifications required"
    - "All 38 characterization tests pass after extraction"
  artifacts:
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt"
      provides: "Workout lifecycle, BLE commands, auto-stop, rest timer, session persistence"
      contains: "class ActiveSessionEngine"
    - path: "shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt"
      provides: "Orchestration layer delegating to sub-managers"
      contains: "activeSessionEngine."
  key_links:
    - from: "ActiveSessionEngine.kt"
      to: "WorkoutCoordinator.kt"
      via: "coordinator property for state access"
      pattern: "coordinator\\."
    - from: "DefaultWorkoutSessionManager.kt"
      to: "ActiveSessionEngine.kt"
      via: "delegation of workout methods"
      pattern: "activeSessionEngine\\."
    - from: "DefaultWorkoutSessionManager.kt"
      to: "RoutineFlowManager.kt"
      via: "cross-cutting orchestration calls"
      pattern: "routineFlowManager\\."
---

<objective>
Extract all workout lifecycle logic from DefaultWorkoutSessionManager into a new ActiveSessionEngine class (~1,800 lines), reducing DWSM to an ~800-line orchestration layer. Update WorkoutSessionManager interface if method signatures changed. Verify MainViewModel API is unchanged.

Purpose: This is the final and largest extraction — ActiveSessionEngine contains the core workout engine (start/stop, rep processing, auto-stop, BLE commands, rest timer, session persistence). After this, DWSM is a thin orchestration layer coordinating between RoutineFlowManager and ActiveSessionEngine.

Output: ActiveSessionEngine.kt (~1,800 lines), DWSM reduced to ~800 lines, WorkoutSessionManager interface updated if needed, all 38 tests passing.
</objective>

<execution_context>
@C:/Users/dasbl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dasbl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-manager-decomposition/02-RESEARCH.md
@.planning/phases/02-manager-decomposition/02-01-SUMMARY.md
@.planning/phases/02-manager-decomposition/02-02-SUMMARY.md
@.planning/phases/02-manager-decomposition/02-03-SUMMARY.md
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/WorkoutCoordinator.kt
@shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/RoutineFlowManager.kt
@shared/src/commonTest/kotlin/com/devil/phoenixproject/testutil/DWSMTestHarness.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ActiveSessionEngine and extract workout lifecycle methods from DWSM</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/ActiveSessionEngine.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/DefaultWorkoutSessionManager.kt
  </files>
  <action>
**CRITICAL: Move methods one at a time (or in small tightly-coupled groups). Run all 38 tests after EACH move. Commit after each passing test run. Revert immediately on any failure.**

**Step 1: Create ActiveSessionEngine.kt scaffold.**

Create the class in the same package as DWSM:
```kotlin
class ActiveSessionEngine(
    val coordinator: WorkoutCoordinator,
    private val bleRepository: BleRepository,
    private val workoutRepository: WorkoutRepository,
    private val exerciseRepository: ExerciseRepository,
    private val personalRecordRepository: PersonalRecordRepository,
    private val repCounter: RepCounterFromMachine,
    private val preferencesManager: PreferencesManager,
    private val gamificationManager: GamificationManager,
    private val trainingCycleRepository: TrainingCycleRepository,
    private val completedSetRepository: CompletedSetRepository,
    private val syncTriggerManager: SyncTriggerManager?,
    private val settingsManager: SettingsManager,
    private val scope: CoroutineScope
)
```

Same CoroutineScope as DWSM — NO new scope creation.

**Step 2: Move init block collectors 3-8 into ActiveSessionEngine.**

ActiveSessionEngine's `init {}` block should launch these collectors (preserving original order):
3. **RepCounter onRepEvent** (DWSM lines ~405-433): Emits haptics, triggers handleSetCompletion
4. **HandleState collector** (DWSM lines ~438-488): Auto-start/auto-stop based on handle state
5. **Deload events collector** (DWSM lines ~491-515): Firmware-based auto-stop
6. **Rep events collector** (DWSM lines ~518-525): `bleRepository.repEvents.collect`
7. **Metrics flow collector** (DWSM lines ~532-538): `bleRepository.metricsFlow.collect`
8. **Heuristic data collector** (DWSM lines ~541-560): Echo mode force feedback

Remove them from DWSM's init block. DWSM's init block should now be empty or nearly empty (only orchestration wiring).

IMPORTANT: Construction order in DWSM must be: coordinator -> routineFlowManager -> activeSessionEngine. This ensures RoutineFlowManager's collectors (1-2) launch before ActiveSessionEngine's collectors (3-8), preserving the original ordering.

Run tests after moving each collector. Commit per collector or per tightly-coupled pair.

**Step 3: Extract Calculation Helpers (Round 1-ish).**

Move:
- `calculateSetSummaryMetrics(...)` — enhanced metrics calculation
- `resetAutoStopTimer()` / `resetStallTimer()` / `resetAutoStopState()`
- `isInAmrapStartupGrace(hasMeaningfulRange)`
- `shouldEnableAutoStop(params)`
- `collectMetricForHistory(metric)`

Run tests. Commit.

**Step 4: Extract Auto-Stop System (Round 8 area).**

Move:
- `handleMonitorMetric(metric)` — THE hot path method (10-50Hz)
- `checkAutoStop(metric)` — velocity + position detection
- `requestAutoStop()` / `triggerAutoStop()`

These have ZERO routine dependencies (confirmed in research). They only read/write coordinator state.

Run tests. Commit.

**Step 5: Extract Rep Processing.**

Move:
- `handleRepNotification(notification)` — rep counter processing

Run tests. Commit.

**Step 6: Extract Weight Adjustment (Round 5).**

Move:
- `adjustWeight(newWeightKg, sendToMachine)`
- `sendWeightUpdateToMachine(weightKg)` — BLE weight command
- `incrementWeight()` / `decrementWeight()` / `setWeightPreset()`
- `getLastWeightForExercise(exerciseId)` / `getPrWeightForExercise(exerciseId)`

Per user decision: BLE commands stay co-located with state transitions in ActiveSessionEngine.

Run tests. Commit.

**Step 7: Extract Just Lift (Round 6).**

Move:
- `enableHandleDetection()` / `disableHandleDetection()`
- `prepareForJustLift()`
- `getJustLiftDefaults()` / `saveJustLiftDefaults(defaults)`
- `saveJustLiftDefaultsFromWorkout()` — private
- `getSingleExerciseDefaults(exerciseId)` / `saveSingleExerciseDefaults(defaults)`
- `saveSingleExerciseDefaultsFromWorkout()` — private

Run tests. Commit.

**Step 8: Extract Training Cycles (Round 7).**

Move:
- `loadRoutineFromCycle(routineId, cycleId, dayNumber)` — CROSS-MANAGER: this calls loadRoutine. It needs a callback to DWSM or RoutineFlowManager. Use the same delegation pattern as jumpToExercise() from Plan 02-03.
- `clearCycleContext()`
- `updateCycleProgressIfNeeded()` — private suspend

Run tests. Commit.

**Step 9: Extract Core Workout Lifecycle (Round 8 — the big methods).**

Move:
- `startWorkout(skipCountdown, isJustLiftMode)` — THE biggest method (~250 lines). Contains BLE commands that should stay co-located.
- `stopWorkout(exitingWorkout)` — manual stop (~170 lines)
- `stopAndReturnToSetReady()` — back button during workout
- `pauseWorkout()` / `resumeWorkout()` — pause/resume
- `skipCountdown()` — skip countdown flag
- `resetForNewWorkout()` — reset to Idle
- `updateWorkoutParameters(params)` — parameter updates

Run tests. Commit.

**Step 10: Extract Session Persistence.**

Move:
- `saveWorkoutSession()` — full session save (~140 lines)
- `findPlannedSetId(setIndex)` — private suspend

Run tests. Commit.

**Step 11: Extract Rest Timer and Flow Control.**

Move:
- `startRestTimer()` — rest countdown with display
- `advanceToNextSetInSingleExercise()` — single exercise advance
- `startNextSetOrExercise()` — advance after rest
- `startWorkoutOrSetReady()` — autoplay decision
- `skipRest()` / `startNextSet()` — user skip actions
- `startAutoStartTimer()` / `cancelAutoStartTimer()` — auto-start

**CROSS-CUTTING NOTE:** `startNextSetOrExercise()` may need to call back to DWSM for navigation decisions. Use the same delegation pattern.

Run tests. Commit.

**Step 12: Extract Load Baseline.**

Move:
- `recaptureLoadBaseline()` / `resetLoadBaseline()`

Run tests. Commit.

**Step 13: Handle handleSetCompletion() — the cross-cutting method.**

Per research (Pitfall 5): handleSetCompletion() touches BOTH routine navigation AND workout lifecycle. Split into two phases:
- **Phase A (ActiveSessionEngine):** Stop BLE, save session, emit haptics, show summary (steps 1-4)
- **Phase B (DWSM orchestration):** Rest timer, navigation advancement (steps 5-6)

The ActiveSessionEngine's handleSetCompletion() does Phase A and then calls a callback/delegate to DWSM for Phase B. DWSM's orchestration decides whether to start rest timer or advance.

Run tests. Commit.

**Step 14: Handle proceedFromSummary() — keep in DWSM.**

Per research (Pitfall 7): proceedFromSummary() reads both routine state and workout state to decide the next action. Keep it in DWSM as orchestration. It calls into routineFlowManager and activeSessionEngine as needed.

Verify it's still in DWSM and working. Run tests. Commit.

**Step 15: Update DWSM delegation and final cleanup.**

Replace all moved method bodies with delegation:
```kotlin
fun startWorkout(...) = activeSessionEngine.startWorkout(...)
fun stopWorkout(...) = activeSessionEngine.stopWorkout(...)
// etc.
```

DWSM constructs ActiveSessionEngine:
```kotlin
val activeSessionEngine = ActiveSessionEngine(
    coordinator = coordinator,
    bleRepository = bleRepository,
    // ... all deps
    scope = scope
)
```

Verify DWSM is now ~800 lines of orchestration + delegation.

Run all tests. Commit.

**CONSTRAINTS (from user decisions):**
- ActiveSessionEngine NEVER holds a reference to RoutineFlowManager
- All state access through coordinator
- BLE commands stay co-located with state transitions in ActiveSessionEngine
- Same CoroutineScope as DWSM (NO new scope creation)
- Test after EVERY method move
- Atomic git commits per move
- If tests fail, revert immediately — never fix forward
  </action>
  <verify>
Run `./gradlew :shared:testDebugUnitTest` — all 38 tests pass.
Verify ActiveSessionEngine.kt exists and is ~1,800 lines.
Verify DWSM is reduced to ~800 lines.
Verify DWSM's workout methods are delegation-only.
  </verify>
  <done>
ActiveSessionEngine.kt exists with all workout lifecycle logic. DWSM reduced to orchestration layer. Init block collectors 3-8 moved to ActiveSessionEngine. All 38 tests pass. Atomic git commits for every move.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update WorkoutSessionManager interface, MainViewModel, and test harness</name>
  <files>
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/manager/BleConnectionManager.kt
    shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/viewmodel/MainViewModel.kt
    shared/src/commonTest/kotlin/com/devil/phoenixproject/testutil/DWSMTestHarness.kt
  </files>
  <action>
**Step 1: Update WorkoutSessionManager interface (if needed).**

Per user decision: "WorkoutSessionManager interface gets updated too — keep the abstraction honest." If any method signatures were cleaned up during decomposition, update the interface to match. The interface is defined in BleConnectionManager.kt as `WorkoutStateProvider`.

Check what `WorkoutStateProvider` actually exposes and whether it needs updating based on the new structure.

**Step 2: Verify MainViewModel API unchanged.**

Read MainViewModel.kt and confirm:
- All public methods/properties that UI screens use are still present
- No new imports of sub-managers (MainViewModel talks to DWSM only)
- Construction still works with manual wiring

If DWSM method signatures were cleaned up (per user decision allowing this), update MainViewModel to match. Verify no UI screen files need changes.

Grep for imports of DefaultWorkoutSessionManager in screen files to verify none import sub-managers:
```bash
grep -r "RoutineFlowManager\|ActiveSessionEngine\|WorkoutCoordinator" shared/src/commonMain/kotlin/com/devil/phoenixproject/presentation/screen/
```
Should return zero results.

**Step 3: Final test harness verification.**

Ensure DWSMTestHarness still works. Add convenience accessors if useful:
```kotlin
val activeSessionEngine get() = dwsm.activeSessionEngine
```

Run all 38 tests one final time.

**Step 4: Final verification sweep.**

Run full build:
```bash
./gradlew :shared:testDebugUnitTest
./gradlew :androidApp:assembleDebug
```

Both must pass. The Android build verifies no compilation errors in the full dependency chain.

Commit final cleanup.
  </action>
  <verify>
Run `./gradlew :shared:testDebugUnitTest` — all 38 tests pass.
Run `./gradlew :androidApp:assembleDebug` — full Android build succeeds.
Verify no UI screen files import sub-managers.
  </verify>
  <done>
WorkoutSessionManager interface updated (if needed). MainViewModel works with decomposed DWSM. No UI screens changed. Full build passes. All 38 tests pass. Phase 2 complete.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew :shared:testDebugUnitTest` — all 38 tests pass
2. `./gradlew :androidApp:assembleDebug` — full Android build succeeds
3. ActiveSessionEngine.kt exists in the manager package (~1,800 lines)
4. DWSM is ~800 lines (orchestration + delegation)
5. ActiveSessionEngine does NOT import or reference RoutineFlowManager
6. No UI screen files reference sub-managers directly
7. handleMonitorMetric() lives in ActiveSessionEngine
8. proceedFromSummary() lives in DWSM
9. All BLE commands are in ActiveSessionEngine (co-located with state transitions)
</verification>

<success_criteria>
- ActiveSessionEngine.kt exists (~1,800 lines) with all workout lifecycle logic
- DWSM reduced to ~800 lines orchestration layer
- All sub-managers communicate only through WorkoutCoordinator
- MainViewModel API unchanged — no UI screen modifications
- Full Android build succeeds
- All 38 Phase 1 characterization tests pass
- Atomic git commits per method move
</success_criteria>

<output>
After completion, create `.planning/phases/02-manager-decomposition/02-04-SUMMARY.md`
</output>
